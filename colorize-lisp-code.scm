(define (get-color depth)
  (define colors '#(red green blue yellow purple cyan))
  (define no-colors (vector-length colors))
  (vector-ref colors (remainder depth no-colors)))

(define (has-inner-list? exp)
  (if (list? exp)
    (accumulate boolean/or #f (map list? exp))
    #f))

(define (make-color-expr-list exp)
  (define (inner depth exp color-escape-return)
    (let ((current-color-escape (make-color-escape 'none (get-color depth))))
      (list current-color-escape
            (if (list? exp)
              (map (lambda (e) 
                     (if (list? e)
                       (inner (+ depth 1) e current-color-escape)
                       e))
                   exp)
              exp)
            color-escape-return))) 
  (inner 0 exp escape-color-reset))

(define (deep-map func exp)
  (map
    (lambda (e)
      (if (list? e)
        (deep-map func e)
        (func e)))
    exp))

(define (deep-print expr)
  (define (break-out-escapes full-expr)
    (define (inner done remaining)
      (if (null? remaining)
        done
        (let ((next (car remaining)))
          (if (list? next)
            (inner (cons (caddr next) (cons (cadr next) (cons (car next) done))) (cdr remaining))
            (inner (cons next done) (cdr remaining))))))
    (let ((ret-val (reverse (inner '() full-expr))))
      (map (lambda (l) (if (has-inner-list? l)
                         (break-out-escapes l)
                         l))
           ret-val)))
  (let ((start-esc (car expr))
        (exp (cadr expr))
        (end-esc (caddr expr)))
    (display start-esc)
    (if (has-inner-list? exp)
      (display (break-out-escapes exp))
      (display exp))
    (display end-esc)))
